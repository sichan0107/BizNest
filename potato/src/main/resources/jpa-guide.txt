JPA의 동작과 특징의 기록

1. JPA의 엔티티 더티 체킹?
 - JPA는 영속성 컨텍스트가 최초 DB에서 엔티티를 조회해올 때 그 엔티티 값의 스냅샷을 저장한다.
 - 만약 트랜잭션 커밋 시점에 스냅샷과 엔티티의 정보가 달라진다면 (이때 더티체킹이라함)
 - 자동으로 update를 하게된다. (persist를 한다고 실제 저장하진 않음. 무조건 commit)
 - 추가적으로 JPA는 update를 할때 엔티티의 모든 필드를 update 대상으로 본다.
  > 왜냐면 모든 필드를 업데이트 하는 쿼리는 캐싱해놨다가 다음에 엔티티를 저장할 때도 파싱된 쿼리문을 재사용해 성능을 높이는 컨셉.
  > 하지만 필드가 너무 길다? 그럼 정규화가 잘못된거다. 15개 이상이면 잘못된거다.
  > 그리고 변경된 필드만 수정쿼리를 날리고 싶다면 @DynamicUpdate를 엔티티 클래스 상단에 쓴다.

2. 엔티티 ID 생성 방식
 - 직접할당
 - Identity Generate : MySql 같은데서 씀. persist 하는 시점에 Insert 쿼리 실행, 이때 식별자 생김
 - 시퀀스 : persist 시점에 식별자 생김. insert 실행 안함.
 - 테이블 : persist 시점에 식별자 생김. insert 실행 안함. (잘 안씀. 시퀀스가 있을 경우는 시퀀스를 쓰고, 아니면 자동증가를 씀)

3. @Embeddable / @Embedded
 - @Entity 클래스 안에 따로 뺄 수 있는 도메인은 @Embeddable로 빼낸다.
 - 그리고 @Entity 클래스에서 사용할 때 @Embedded로 쓴다.
 - 도메인 모델을 더 잘 표현할 수 있다. (예시로 Hotel 과 Address를 떠올린다)
 - 추가로, 엔티티 안에 같은 타입의 @Embedded 필드가 있다면 중복 에러가 나기때문에, @AttributeOverride를 써서 재정의 해준다.

4. @SecondaryTable ?
 - 엔티티 클래스의 @Embedded 클래스를 다른 테이블에 저장하고 싶을 때 사용한다.
 - 두 가지 사용방법이 있다.

5. 엔티티 클래스에 Collection 타입 필드가 있다면?
 - @ElementCollection
  > 기본값은 Fetch_Type : Lazy라 엔티티를 조회할때 임베디드 필드도 조회하는 게 아니라, 임베디드 필드 값을 사용할 떄 조회한다.
  > Eager로 변경 시 Left Join을 걸어서 엔티티 조회할 때, 한 방에 가져온다.
 - @CollectionTable

6. JPA의 영속 컨텍스트는 영속 상태인 엔티티만 관리, 변경 추적 한다.
 - EntityManager의 find(), persist()를 거쳐서 나온 엔티티만 추적의 대상이 된다.
 - new Entity() 로 생성한 엔티티는 아직 추적 대상이 아니다. persist()를 호출해야만 대상이된다.
 - 추가로, 대량 변경 쿼리는 JPA를 사용할 필요가 없다. 엔티티매니저가 메모리에 대량의 데이터를 캐시해야하는데 손해다.
 - 예를들면 배치작업이 될듯?

7. JPQL 사용 시 고려해볼 상태 (일반 쿼리를 사용하길 권장하는 상황)
 - SQL과 굉장히 흡사한 쿼리 작성법
 - 여러 테이블 조인 (레거시 테이블 조인 - 정규화가 안된...)
 - DBNS에 특화된 쿼리 필요 시 (오라클 힌트 같은....)
 - 서브 쿼리 필요할때
 - 통계, 대량 데이터 조회 / 처리 시

8. Criteria 사용 시 장점과 단점 (고려해볼 사항)
 - JPQL은 쿼리문자열 기반이기 때문에 동적 쿼리가 쉽지않다. Criteria는 메소드체인 기법으로 Java 소스를 이용해 짜기 때문에 동적 가능
 - 대부분의 장점은 JPQL과 비슷.... 한계점도 비슷 (동적 쿼리를 사용해야할 때 추천한다)
 - 고려해볼 사항 중 복잡한 목록 및 상세 조회는 걍 SQL 쓰자

9. Criteria 사용할 때 검색 조건을 더 잘 다루기 위해 Specification 인터페이스를 쓰자.
 - 인터페이스라 구현체가 필요하다.
 - 구현 클래스 만들기 귀찮으면 람다식도 된다.
 - 검색조건을 추가할때 유용하다.

10. @Query 애노테이션은 JPQL도되고, SQL도 가능하다.
 - @Query (value = "select ~~ ", nativeQuery = true ) -> 순수 sql 가능

11. Jpa의 repo는 여러 종류가 있다. 하지만 가장 기본적인 Repository 만 상속 받아서 딱 필요한 메서드만 구현하자.
 - JpaRepository를 구현해서 단위테스트를 하려면 20개의 메서드를 구현해야한다.
 - 단위 테스트 시 repo의 가짜 객체를 만들어야하는데 Repository는 find, save 두개만 하면된다. (구현해야하는 메서드가 적다)
 - 가능하다면 필요한 메서드만 구현해서, 오용할 가능성을 줄인다.
  > findById, findOne, save 정도는 필수 + 도메인이 제공할 기능 몇개 정도만!
 - 조회 모델의 경우도 마찬가지다.
  > 다양한 스펙 조합이 필요하면 (검색 조건이 필요하면 ) JPA
  > 단순 조회면 Jdbc 템플릿
  > 쿼리가 복잡하면 Mybatis

12. CQRS 패턴을 생각하자. (Command Query Responsibility Segregation / 명령과 쿼리 책임의 분리 )
 - 명령 (데이터변경) 역할을 수행하는 구성과        -> 주문취소, 예약하기 등등의 변경기능
 - 쿼리 (데이터조회) 역할을 수행하는 구성을 나누자. -> 주문목록 조회 등

 - Service, Dao, Dto등 변경과 조회에 따라 아예 분리하고 각 클래스별로 하나의 동작 책임만을 가진다. (변경은 변경, 조회는 조회)
 - 이렇게하면 소스파일이 많아져 중복되고 오래걸리고 귀찮다. 그래도 해야하는 이유?
  > 예를들어 Member라는 클래스를 단일 모델로 계속 필드값과 메소드를 추가하다보면 Member 클래스의 책임이 모호해진다. (단일책임원칙 위배)
  > Member인데 마지막 주문 일시 같은 기능, 필드가 들어가면 Member 클래스를 조회할때 Order 테이블도 찾아야한다.

13. 마무리
 - JpaRepository를 상속하면 편하지만
 - 단위 테스트에서 가짜 구현이 어렵고
 - CQRS에 맞지 않음
 - Repository를 상속하고 필요한 메소드만 추가

